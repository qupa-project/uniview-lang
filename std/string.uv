include llvm "./string.ll";
import "memory.uv" as Memory;

external assume {
	fn "qupa.cstring.size" (str: cstring): u64 as sizeof;
}

struct String {
	data: addr_space;
	size: u64;
}

impl String {
	fn New(str: cstring): String {
		let size = sizeof($str);
		let out = String {
			data: Memory.Alloc(size),
			size: size
		};

		let other = bitcast#[addr_space](str);
		Memory.Move($out.data, $other, out.size, false);

		return out;
	}

	fn Append(this: @String, other: String) {
		let nx_len = this.size + other.size - cast#[u64](1);
		this.data = Memory.Realloc(this.data, nx_len);

		let insert = Memory.Offset($this.data, cast#[i64](this.size) -1 );
		Memory.Move(insert, $other.data, other.size, false);

		this.size = nx_len;
	}


	fn Slice(this: @String, begin: u64): String {
		return String.Slice(@this, begin, this.size);
	}

	fn Slice(this: @String, begin: u64, end: u64): String {
		if (begin > this.size) {
			begin = this.size;
		}
		if (end > this.size - cast#[u64](1)) {
			end = this.size - cast#[u64](1);
		}

		// Create a space for the new data
		let length = end - begin;
		let size = length + cast#[u64](1);
		let sub = String {
			size: size,
			data: Memory.Alloc(size)
		};

		// Move the taken slice to the new string
		let sect_start = Memory.Offset($this.data, cast#[i64](begin));
		Memory.Move($sub.data, $sect_start, length, false);

		// Fix the hole in the current string
		let sect_end = Memory.Offset($this.data, cast#[i64](end));
		Memory.Move($sect_start, $sect_end, this.size-end, false);

		// Resize the string
		this.size = this.size - length;
		this.data = Memory.Realloc(this.data, this.size);

		// Add the null terminator
		let terminator = Memory.Offset($sub.data, cast#[i64](sub.size) -1);
		Memory.Set(terminator, cast#[i8](0), cast#[u64](1), false);

		return sub;
	}

	fn Slice(this: String, begin: u64): String {
		let end = this.size;
		return String.Slice(this, begin, end);
	}

	fn Slice(this: String, begin: u64, end: u64): String {
		if (begin > this.size) {
			begin = this.size;
		}
		if (end > this.size - cast#[u64](1)) {
			end = this.size - cast#[u64](1);
		}

		// Create a space for the new data
		let length = end - begin;
		let size = length + cast#[u64](1);
		let sub = String {
			size: size,
			data: Memory.Alloc(size)
		};

		// Move the taken slice to the new string
		let sect_start = Memory.Offset($this.data, cast#[i64](begin));
		Memory.Copy($sub.data, $sect_start, length, false);

		// Add the null terminator
		let terminator = Memory.Offset($sub.data, cast#[i64](sub.size) -1);
		Memory.Set(terminator, cast#[i8](0), cast#[u64](1), false);
		return sub;
	}


	fn Length(this: &String): u64 {
		let out: u64 = this.size - cast#[u64](1);
		return out;
	}
}


impl Clone for String {
	fn clone(this: @String): String {
		// Initiliase the data structure
		let data = Memory.Alloc(this.size);

		let out = String {
			data: data,
			size: this.size
		};

		// Copy the blob data to the new allocation
		Memory.Copy($out.data, $this.data, this.size, false);

		return out;
	}
}

impl Drop for String {
	fn drop(this: @String) {
		Memory.Free($this.data);
	}
}


fn puts(str: @String) {
	printf("%s", bitcast#[cstring]($str.data));
}

fn puts(str: String) {
	printf("%s", bitcast#[cstring]($str.data));
}